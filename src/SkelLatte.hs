module SkelLatte where

-- Haskell module generated by the BNF converter

import AbsLatte
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transProgram :: Program -> Result
transProgram x = case x of
  Program topdefs  -> failure x


transFunDef :: FunDef -> Result
transFunDef x = case x of
  FunDef type' id args block  -> failure x


transTopDef :: TopDef -> Result
transTopDef x = case x of
  FnDef fundef  -> failure x
  StDef type' atts  -> failure x


transArg :: Arg -> Result
transArg x = case x of
  Arg type' id  -> failure x


transAtt :: Att -> Result
transAtt x = case x of
  Att type' id  -> failure x
  Meth fundef  -> failure x


transNew :: New -> Result
transNew x = case x of
  NewArr type' expr  -> failure x
  NewSt type'  -> failure x


transAssignable :: Assignable -> Result
transAssignable x = case x of
  AIdent id  -> failure x
  AArr id expr  -> failure x
  AMeth id exprs  -> failure x


transAssign :: Assign -> Result
transAssign x = case x of
  AList assignables  -> failure x
  ANewDot new assignables  -> failure x
  ANewArr new expr  -> failure x


transBlock :: Block -> Result
transBlock x = case x of
  Block stmts  -> failure x


transStmt :: Stmt -> Result
transStmt x = case x of
  Empty  -> failure x
  BStmt block  -> failure x
  Decl type' items  -> failure x
  Ass assign expr  -> failure x
  Incr assign  -> failure x
  Decr assign  -> failure x
  Ret expr  -> failure x
  VRet  -> failure x
  Cond expr stmt  -> failure x
  CondElse expr stmt1 stmt2  -> failure x
  While expr stmt  -> failure x
  SExp expr  -> failure x
  For type' id expr stmt  -> failure x


transItem :: Item -> Result
transItem x = case x of
  NoInit id  -> failure x
  Init id expr  -> failure x


transType :: Type -> Result
transType x = case x of
  Int  -> failure x
  Str  -> failure x
  Bool  -> failure x
  Void  -> failure x
  Array type'  -> failure x
  Clas id  -> failure x
  Fun type' types  -> failure x


transExpr :: Expr -> Result
transExpr x = case x of
  EVar assign  -> failure x
  ELitInt n  -> failure x
  ELitTrue  -> failure x
  ELitFalse  -> failure x
  EString str  -> failure x
  Neg expr  -> failure x
  Not expr  -> failure x
  EMul expr1 mulop2 expr3  -> failure x
  EAdd expr1 addop2 expr3  -> failure x
  ERel expr1 relop2 expr3  -> failure x
  EAnd expr1 expr2  -> failure x
  EOr expr1 expr2  -> failure x
  ECast type'  -> failure x
  ENew new  -> failure x


transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus  -> failure x
  Minus  -> failure x


transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times  -> failure x
  Div  -> failure x
  Mod  -> failure x


transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH  -> failure x
  LE  -> failure x
  GTH  -> failure x
  GE  -> failure x
  EQU  -> failure x
  NE  -> failure x



